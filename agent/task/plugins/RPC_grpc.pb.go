// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package plugins

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// LoggerClient is the client API for Logger service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LoggerClient interface {
	Emerg(ctx context.Context, in *ProtectionLog, opts ...grpc.CallOption) (*Reply, error)
	Alert(ctx context.Context, in *ProtectionLog, opts ...grpc.CallOption) (*Reply, error)
	Crit(ctx context.Context, in *ProtectionLog, opts ...grpc.CallOption) (*Reply, error)
	Error(ctx context.Context, in *ProtectionLog, opts ...grpc.CallOption) (*Reply, error)
	Warn(ctx context.Context, in *ProtectionLog, opts ...grpc.CallOption) (*Reply, error)
	Notice(ctx context.Context, in *ProtectionLog, opts ...grpc.CallOption) (*Reply, error)
	Info(ctx context.Context, in *ProtectionLog, opts ...grpc.CallOption) (*Reply, error)
	Debug(ctx context.Context, in *ProtectionLog, opts ...grpc.CallOption) (*Reply, error)
	EmergSysLog(ctx context.Context, in *SystemLog, opts ...grpc.CallOption) (*Reply, error)
	AlertSysLog(ctx context.Context, in *SystemLog, opts ...grpc.CallOption) (*Reply, error)
	CritSysLog(ctx context.Context, in *SystemLog, opts ...grpc.CallOption) (*Reply, error)
	ErrorSysLog(ctx context.Context, in *SystemLog, opts ...grpc.CallOption) (*Reply, error)
	WarnSysLog(ctx context.Context, in *SystemLog, opts ...grpc.CallOption) (*Reply, error)
	NoticeSysLog(ctx context.Context, in *SystemLog, opts ...grpc.CallOption) (*Reply, error)
	InfoSysLog(ctx context.Context, in *SystemLog, opts ...grpc.CallOption) (*Reply, error)
	DebugSysLog(ctx context.Context, in *SystemLog, opts ...grpc.CallOption) (*Reply, error)
	EmergOpLog(ctx context.Context, in *OperationLog, opts ...grpc.CallOption) (*Reply, error)
	AlertOpLog(ctx context.Context, in *OperationLog, opts ...grpc.CallOption) (*Reply, error)
	CritOpLog(ctx context.Context, in *OperationLog, opts ...grpc.CallOption) (*Reply, error)
	ErrorOpLog(ctx context.Context, in *OperationLog, opts ...grpc.CallOption) (*Reply, error)
	WarnOpLog(ctx context.Context, in *OperationLog, opts ...grpc.CallOption) (*Reply, error)
	NoticeOpLog(ctx context.Context, in *OperationLog, opts ...grpc.CallOption) (*Reply, error)
	InfoOpLog(ctx context.Context, in *OperationLog, opts ...grpc.CallOption) (*Reply, error)
	DebugOpLog(ctx context.Context, in *OperationLog, opts ...grpc.CallOption) (*Reply, error)
}

type loggerClient struct {
	cc grpc.ClientConnInterface
}

func NewLoggerClient(cc grpc.ClientConnInterface) LoggerClient {
	return &loggerClient{cc}
}

func (c *loggerClient) Emerg(ctx context.Context, in *ProtectionLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/Emerg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) Alert(ctx context.Context, in *ProtectionLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/Alert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) Crit(ctx context.Context, in *ProtectionLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/Crit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) Error(ctx context.Context, in *ProtectionLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/Error", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) Warn(ctx context.Context, in *ProtectionLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/Warn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) Notice(ctx context.Context, in *ProtectionLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/Notice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) Info(ctx context.Context, in *ProtectionLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/Info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) Debug(ctx context.Context, in *ProtectionLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/Debug", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) EmergSysLog(ctx context.Context, in *SystemLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/EmergSysLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) AlertSysLog(ctx context.Context, in *SystemLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/AlertSysLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) CritSysLog(ctx context.Context, in *SystemLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/CritSysLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) ErrorSysLog(ctx context.Context, in *SystemLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/ErrorSysLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) WarnSysLog(ctx context.Context, in *SystemLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/WarnSysLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) NoticeSysLog(ctx context.Context, in *SystemLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/NoticeSysLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) InfoSysLog(ctx context.Context, in *SystemLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/InfoSysLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) DebugSysLog(ctx context.Context, in *SystemLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/DebugSysLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) EmergOpLog(ctx context.Context, in *OperationLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/EmergOpLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) AlertOpLog(ctx context.Context, in *OperationLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/AlertOpLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) CritOpLog(ctx context.Context, in *OperationLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/CritOpLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) ErrorOpLog(ctx context.Context, in *OperationLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/ErrorOpLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) WarnOpLog(ctx context.Context, in *OperationLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/WarnOpLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) NoticeOpLog(ctx context.Context, in *OperationLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/NoticeOpLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) InfoOpLog(ctx context.Context, in *OperationLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/InfoOpLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerClient) DebugOpLog(ctx context.Context, in *OperationLog, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/plugins.logger/DebugOpLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LoggerServer is the server API for Logger service.
// All implementations must embed UnimplementedLoggerServer
// for forward compatibility
type LoggerServer interface {
	Emerg(context.Context, *ProtectionLog) (*Reply, error)
	Alert(context.Context, *ProtectionLog) (*Reply, error)
	Crit(context.Context, *ProtectionLog) (*Reply, error)
	Error(context.Context, *ProtectionLog) (*Reply, error)
	Warn(context.Context, *ProtectionLog) (*Reply, error)
	Notice(context.Context, *ProtectionLog) (*Reply, error)
	Info(context.Context, *ProtectionLog) (*Reply, error)
	Debug(context.Context, *ProtectionLog) (*Reply, error)
	EmergSysLog(context.Context, *SystemLog) (*Reply, error)
	AlertSysLog(context.Context, *SystemLog) (*Reply, error)
	CritSysLog(context.Context, *SystemLog) (*Reply, error)
	ErrorSysLog(context.Context, *SystemLog) (*Reply, error)
	WarnSysLog(context.Context, *SystemLog) (*Reply, error)
	NoticeSysLog(context.Context, *SystemLog) (*Reply, error)
	InfoSysLog(context.Context, *SystemLog) (*Reply, error)
	DebugSysLog(context.Context, *SystemLog) (*Reply, error)
	EmergOpLog(context.Context, *OperationLog) (*Reply, error)
	AlertOpLog(context.Context, *OperationLog) (*Reply, error)
	CritOpLog(context.Context, *OperationLog) (*Reply, error)
	ErrorOpLog(context.Context, *OperationLog) (*Reply, error)
	WarnOpLog(context.Context, *OperationLog) (*Reply, error)
	NoticeOpLog(context.Context, *OperationLog) (*Reply, error)
	InfoOpLog(context.Context, *OperationLog) (*Reply, error)
	DebugOpLog(context.Context, *OperationLog) (*Reply, error)
	mustEmbedUnimplementedLoggerServer()
}

// UnimplementedLoggerServer must be embedded to have forward compatible implementations.
type UnimplementedLoggerServer struct {
}

func (*UnimplementedLoggerServer) Emerg(context.Context, *ProtectionLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Emerg not implemented")
}
func (*UnimplementedLoggerServer) Alert(context.Context, *ProtectionLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Alert not implemented")
}
func (*UnimplementedLoggerServer) Crit(context.Context, *ProtectionLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Crit not implemented")
}
func (*UnimplementedLoggerServer) Error(context.Context, *ProtectionLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Error not implemented")
}
func (*UnimplementedLoggerServer) Warn(context.Context, *ProtectionLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Warn not implemented")
}
func (*UnimplementedLoggerServer) Notice(context.Context, *ProtectionLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Notice not implemented")
}
func (*UnimplementedLoggerServer) Info(context.Context, *ProtectionLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Info not implemented")
}
func (*UnimplementedLoggerServer) Debug(context.Context, *ProtectionLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Debug not implemented")
}
func (*UnimplementedLoggerServer) EmergSysLog(context.Context, *SystemLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmergSysLog not implemented")
}
func (*UnimplementedLoggerServer) AlertSysLog(context.Context, *SystemLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AlertSysLog not implemented")
}
func (*UnimplementedLoggerServer) CritSysLog(context.Context, *SystemLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CritSysLog not implemented")
}
func (*UnimplementedLoggerServer) ErrorSysLog(context.Context, *SystemLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ErrorSysLog not implemented")
}
func (*UnimplementedLoggerServer) WarnSysLog(context.Context, *SystemLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WarnSysLog not implemented")
}
func (*UnimplementedLoggerServer) NoticeSysLog(context.Context, *SystemLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NoticeSysLog not implemented")
}
func (*UnimplementedLoggerServer) InfoSysLog(context.Context, *SystemLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InfoSysLog not implemented")
}
func (*UnimplementedLoggerServer) DebugSysLog(context.Context, *SystemLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DebugSysLog not implemented")
}
func (*UnimplementedLoggerServer) EmergOpLog(context.Context, *OperationLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmergOpLog not implemented")
}
func (*UnimplementedLoggerServer) AlertOpLog(context.Context, *OperationLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AlertOpLog not implemented")
}
func (*UnimplementedLoggerServer) CritOpLog(context.Context, *OperationLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CritOpLog not implemented")
}
func (*UnimplementedLoggerServer) ErrorOpLog(context.Context, *OperationLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ErrorOpLog not implemented")
}
func (*UnimplementedLoggerServer) WarnOpLog(context.Context, *OperationLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WarnOpLog not implemented")
}
func (*UnimplementedLoggerServer) NoticeOpLog(context.Context, *OperationLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NoticeOpLog not implemented")
}
func (*UnimplementedLoggerServer) InfoOpLog(context.Context, *OperationLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InfoOpLog not implemented")
}
func (*UnimplementedLoggerServer) DebugOpLog(context.Context, *OperationLog) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DebugOpLog not implemented")
}
func (*UnimplementedLoggerServer) mustEmbedUnimplementedLoggerServer() {}

func RegisterLoggerServer(s *grpc.Server, srv LoggerServer) {
	s.RegisterService(&_Logger_serviceDesc, srv)
}

func _Logger_Emerg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProtectionLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).Emerg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/Emerg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).Emerg(ctx, req.(*ProtectionLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_Alert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProtectionLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).Alert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/Alert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).Alert(ctx, req.(*ProtectionLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_Crit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProtectionLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).Crit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/Crit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).Crit(ctx, req.(*ProtectionLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_Error_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProtectionLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).Error(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/Error",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).Error(ctx, req.(*ProtectionLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_Warn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProtectionLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).Warn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/Warn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).Warn(ctx, req.(*ProtectionLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_Notice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProtectionLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).Notice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/Notice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).Notice(ctx, req.(*ProtectionLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProtectionLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/Info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).Info(ctx, req.(*ProtectionLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_Debug_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProtectionLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).Debug(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/Debug",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).Debug(ctx, req.(*ProtectionLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_EmergSysLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SystemLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).EmergSysLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/EmergSysLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).EmergSysLog(ctx, req.(*SystemLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_AlertSysLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SystemLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).AlertSysLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/AlertSysLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).AlertSysLog(ctx, req.(*SystemLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_CritSysLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SystemLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).CritSysLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/CritSysLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).CritSysLog(ctx, req.(*SystemLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_ErrorSysLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SystemLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).ErrorSysLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/ErrorSysLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).ErrorSysLog(ctx, req.(*SystemLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_WarnSysLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SystemLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).WarnSysLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/WarnSysLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).WarnSysLog(ctx, req.(*SystemLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_NoticeSysLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SystemLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).NoticeSysLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/NoticeSysLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).NoticeSysLog(ctx, req.(*SystemLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_InfoSysLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SystemLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).InfoSysLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/InfoSysLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).InfoSysLog(ctx, req.(*SystemLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_DebugSysLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SystemLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).DebugSysLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/DebugSysLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).DebugSysLog(ctx, req.(*SystemLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_EmergOpLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperationLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).EmergOpLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/EmergOpLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).EmergOpLog(ctx, req.(*OperationLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_AlertOpLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperationLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).AlertOpLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/AlertOpLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).AlertOpLog(ctx, req.(*OperationLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_CritOpLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperationLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).CritOpLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/CritOpLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).CritOpLog(ctx, req.(*OperationLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_ErrorOpLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperationLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).ErrorOpLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/ErrorOpLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).ErrorOpLog(ctx, req.(*OperationLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_WarnOpLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperationLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).WarnOpLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/WarnOpLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).WarnOpLog(ctx, req.(*OperationLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_NoticeOpLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperationLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).NoticeOpLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/NoticeOpLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).NoticeOpLog(ctx, req.(*OperationLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_InfoOpLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperationLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).InfoOpLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/InfoOpLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).InfoOpLog(ctx, req.(*OperationLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logger_DebugOpLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperationLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServer).DebugOpLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.logger/DebugOpLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServer).DebugOpLog(ctx, req.(*OperationLog))
	}
	return interceptor(ctx, in, info, handler)
}

var _Logger_serviceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.logger",
	HandlerType: (*LoggerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Emerg",
			Handler:    _Logger_Emerg_Handler,
		},
		{
			MethodName: "Alert",
			Handler:    _Logger_Alert_Handler,
		},
		{
			MethodName: "Crit",
			Handler:    _Logger_Crit_Handler,
		},
		{
			MethodName: "Error",
			Handler:    _Logger_Error_Handler,
		},
		{
			MethodName: "Warn",
			Handler:    _Logger_Warn_Handler,
		},
		{
			MethodName: "Notice",
			Handler:    _Logger_Notice_Handler,
		},
		{
			MethodName: "Info",
			Handler:    _Logger_Info_Handler,
		},
		{
			MethodName: "Debug",
			Handler:    _Logger_Debug_Handler,
		},
		{
			MethodName: "EmergSysLog",
			Handler:    _Logger_EmergSysLog_Handler,
		},
		{
			MethodName: "AlertSysLog",
			Handler:    _Logger_AlertSysLog_Handler,
		},
		{
			MethodName: "CritSysLog",
			Handler:    _Logger_CritSysLog_Handler,
		},
		{
			MethodName: "ErrorSysLog",
			Handler:    _Logger_ErrorSysLog_Handler,
		},
		{
			MethodName: "WarnSysLog",
			Handler:    _Logger_WarnSysLog_Handler,
		},
		{
			MethodName: "NoticeSysLog",
			Handler:    _Logger_NoticeSysLog_Handler,
		},
		{
			MethodName: "InfoSysLog",
			Handler:    _Logger_InfoSysLog_Handler,
		},
		{
			MethodName: "DebugSysLog",
			Handler:    _Logger_DebugSysLog_Handler,
		},
		{
			MethodName: "EmergOpLog",
			Handler:    _Logger_EmergOpLog_Handler,
		},
		{
			MethodName: "AlertOpLog",
			Handler:    _Logger_AlertOpLog_Handler,
		},
		{
			MethodName: "CritOpLog",
			Handler:    _Logger_CritOpLog_Handler,
		},
		{
			MethodName: "ErrorOpLog",
			Handler:    _Logger_ErrorOpLog_Handler,
		},
		{
			MethodName: "WarnOpLog",
			Handler:    _Logger_WarnOpLog_Handler,
		},
		{
			MethodName: "NoticeOpLog",
			Handler:    _Logger_NoticeOpLog_Handler,
		},
		{
			MethodName: "InfoOpLog",
			Handler:    _Logger_InfoOpLog_Handler,
		},
		{
			MethodName: "DebugOpLog",
			Handler:    _Logger_DebugOpLog_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "RPC.proto",
}
